module mojo_top(
    input clk,             // 50MHz clock
    input rst_n,           // reset button (active low)
    output led[8],         // 8 user controllable LEDs
    input cclk,            // configuration clock, AVR ready when high
    output spi_miso,       // AVR SPI MISO
    input spi_ss,          // AVR SPI Slave Select
    input spi_mosi,        // AVR SPI MOSI
    input spi_sck,         // AVR SPI Clock
    output spi_channel[4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,          // AVR TX (FPGA RX)
    output avr_rx,         // AVR RX (FPGA TX)
    input avr_rx_busy,     // AVR RX buffer full

    output io_led[3][8], // LEDs on IO Shield
    output io_seg[8],    // 7-segment LEDs on IO Shield
    output io_sel[4],    // Digit select on IO Shield
    input io_button[5],  // 5 buttons on IO Shield
    input io_dip[3][8]   // DIP switches on IO Shield
)
{

    sig rst; // reset signal

    .clk(clk)
    {
        // The reset conditioner is used to synchronize the reset signal to the FPGA
        // clock. This ensures the entire FPGA comes out of reset at the same time.
        reset_conditioner reset_cond;

        // button input conditioner for io buttons
        button_conditioner io_button_left_button_conditioner;
        button_conditioner io_button_right_button_conditioner;
        button_conditioner io_button_centre_button_conditioner;
        button_conditioner io_button_up_button_conditioner;
        button_conditioner io_button_down_button_conditioner;

        // detect rising edges for io buttons
        edge_detector io_button_left_edge_detector(#RISE(1), #FALL(0));
        edge_detector io_button_right_edge_detector(#RISE(1), #FALL(0));
        edge_detector io_button_centre_edge_detector(#RISE(1), #FALL(0));
        edge_detector io_button_up_edge_detector(#RISE(1), #FALL(0));
        edge_detector io_button_down_edge_detector(#RISE(1), #FALL(0));

        .rst(rst)
        {
            game game;
        }
    }

    always
    {
        reset_cond.in = ~rst_n; // input raw inverted reset signal
        rst = reset_cond.out;   // conditioned reset

        led = 8h00;           // turn LEDs off
        spi_miso = bz;        // not using SPI
        spi_channel = bzzzz;  // not using flags
        avr_rx = bz;          // not using serial port
        io_led = 3x{{8h00}}; // turn LEDs off
        io_seg = 8hff;        // turn segments off
        io_sel = 4hf;         // select no digits

        // dip switches and io button inputs

        // left button
        io_button_left_button_conditioner.in = io_button[3]; // to reduce the bouncing effects of your button
        io_button_left_edge_detector.in = io_button_left_button_conditioner.out; // get the edge of button press
        game.io_button_left = io_button_left_edge_detector.out;

        // right button
        io_button_right_button_conditioner.in = io_button[4];
        io_button_right_edge_detector.in = io_button_right_button_conditioner.out;
        game.io_button_right = io_button_right_edge_detector.out;

        // centre button
        io_button_centre_button_conditioner.in = io_button[1];
        io_button_centre_edge_detector.in = io_button_centre_button_conditioner.out;
        game.io_button_centre = io_button_centre_edge_detector.out;

        // up button
        io_button_up_button_conditioner.in = io_button[0];
        io_button_up_edge_detector.in = io_button_up_button_conditioner.out;
        game.io_button_up = io_button_up_edge_detector.out;

        // down button
        io_button_down_button_conditioner.in = io_button[2];
        io_button_down_edge_detector.in = io_button_down_button_conditioner.out;
        game.io_button_down = io_button_down_edge_detector.out;

        io_led[1] = game.player_position_out[15:8];
        io_led[0] = game.player_position_out[7:0];

    }
}